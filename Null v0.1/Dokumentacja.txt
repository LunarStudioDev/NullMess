W tym pliku znajdzie się wyjaśnienie kodu który używany jest w symulacji.
Jeżeli kod był wyjaśniony w poprzednim fragmencie, nie będzie wyjaśniany znowu.

// Reprezentuje "komentarz", zawiera nieważne dla samej symulacji obiekty,
oraz bardziej szczegółowe opiasnie kodu.

** Reprezentuje ważny do gry kod, tutaj chcesz zaglądać jeżeli nie wiesz
co dana rzecz robi. Może stanowić mniej szczegółową wersję komentarza.


-Pierwszy Obszar-

@ 1.

= public GameObject square; -> 

//public umożliwia interaktowaniem z kodem poza własnym skryptem.
Jest to przydatne wtedy kiedy chcemy zmienić coś w innym skrypcie, lub z zewnątrz, tak jak
jako postać w symulacji zmieniamy wartości kostki.

//GameObject to jakikolwiek obiekt gry. Ważne jest to że nie referuje on do samego kształtu
lub położenia obiektu, tą funkcje czyni Transform. (GameObject.transform).

//square to tylko nazwa którą przepisujemy public GameObject. Nie musi ona być ona taka
sama jak nazwa obiektu, a tak naprawdę może być jakakolwiek. "public" umożliwia nam
przeciągnięcie obiektu z UI do wyznaczonego pola, bez potrzeby wpisywania w kodzie
lokacji. Jest to jeszcze bardziej przydatne kiedy np. zmieniamy położenie danego
pliku, ponieważ public automatycznie zaaktualizuje lokację.

= private rb = square.GetComponent<RigidBody>(); ->

//.GetComponent<>() odpowiada za wyszukanie danego elementu obiektu.
Nie szuka on w dzieciach elementów, do tego używamy .GetComponentInChildren.
Szukamy komponentu nazwanego RigidBody, i wrzucamy go do variable rb.
(Co to są elementy? Elementem jest np. skrypt dołączony do bloku, kolizja, RigidBody.)

//RigidBody jest obiektem odpowiedzialnym za fizykę obiektów. Jest to zbyt szeroki
element aby go dokładnie wyjaśniać.

= rb.velocity = new Vector3(0,0,0); ->

**.velocity decyduje o tym jak szybki jest obiekt, natomiast
**.new Vector3 ustala jego parametry.

//RigidBody.velocity jest obecną prędkością danego obiektu do którego przypięty jest
RigidBody (zwany od teraz jako jego skrótowa nazwa: rb).

//new Vector3(0,0,0) tworzy nowy Vector3 (który jest obrazowaniem przestrzeni 3D jako (x,y,z)).
W tym przypadku korzysta się z niego aby pchnąć kwadrat w odpowiedni kierunek.


@2
**do{} pozwala na odpalenie skryptu używając przypisanego klawisza (F).

//do{} rzadko kiedy jest wykorzystywane samo w sobie, można odpalić go jako funkcję z innego
skryptu, ale lepiej jest do tego użyć normalnych funkcji. Za to, do{}while(); pozwala na
odpalenie kodu w do{} raz, po czym powtórzenie go tyle razy ile while() na to potrzebuje.


